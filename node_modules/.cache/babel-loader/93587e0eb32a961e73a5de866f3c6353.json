{"ast":null,"code":"import _slicedToArray from\"F:\\\\Coding\\\\React\\\\path-finding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import{PriortyQueue}from\"./priortyQueue\";import{gridIndexToArrayIndex,neiboursUnvisitedNode}from\"./algorithmsHelper\";export function dijkstra(grid,startNode){var forPathReconstruction=new Array(grid.length*grid[0].length);var visitedNodesInOrder=[];var dist=new Array(grid.length*grid[0].length).fill(Infinity);dist[gridIndexToArrayIndex(grid[0].length,startNode.row,startNode.col)]=0;var queue=new PriortyQueue();queue.enqueue([startNode.row,startNode.col],0);while(queue.length){var _queue$dequeue=queue.dequeue(),val=_queue$dequeue.val,priorty=_queue$dequeue.priorty;var index=gridIndexToArrayIndex(grid[0].length,val[0],val[1]);grid[val[0]][val[1]].isVisited=true;if(grid[val[0]][val[1]].isFinish){return[dist,forPathReconstruction,visitedNodesInOrder];}if(dist[index]<priorty){continue;}var neibours=neiboursUnvisitedNode(grid,val,visitedNodesInOrder);for(var i=0;i<neibours.length;i++){var _neibours$i=_slicedToArray(neibours[i],2),idx=_neibours$i[0],currDist=_neibours$i[1];var at=gridIndexToArrayIndex(grid[0].length,idx[0],idx[1]);if(grid[idx[0]][idx[1]].isVisited){continue;}var newDist=dist[index]+currDist;if(newDist<dist[at]){forPathReconstruction[at]=grid[val[0]][val[1]];visitedNodesInOrder.push(grid[val[0]][val[1]]);dist[at]=newDist;queue.enqueue(idx,newDist);}}}return[dist,forPathReconstruction,visitedNodesInOrder];}export function getNodesInShortestPathOrderDijkstra(grid,dist,forPathReconstruction,startNode,endNode){var at=gridIndexToArrayIndex(grid[0].length,endNode[0],endNode[1]);if(dist[at]===Infinity){return[];}var path=[];for(var i=endNode;i!=null;i=forPathReconstruction[gridIndexToArrayIndex(grid[0].length,i.row,i.col)]){path.push(i);}path.reverse();if(path[0]===startNode){console.log(\"DIjkstra Path Length: \",path.length);return path;}else{return[];}}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/Dijkstra.jsx"],"names":["PriortyQueue","gridIndexToArrayIndex","neiboursUnvisitedNode","dijkstra","grid","startNode","forPathReconstruction","Array","length","visitedNodesInOrder","dist","fill","Infinity","row","col","queue","enqueue","dequeue","val","priorty","index","isVisited","isFinish","neibours","i","idx","currDist","at","newDist","push","getNodesInShortestPathOrderDijkstra","endNode","path","reverse","console","log"],"mappings":"sKAAA,OAASA,YAAT,KAA6B,gBAA7B,CACA,OACEC,qBADF,CAEEC,qBAFF,KAGO,oBAHP,CAMA,MAAO,SAASC,CAAAA,QAAT,CAAkBC,IAAlB,CAAwBC,SAAxB,CAAmC,CACxC,GAAMC,CAAAA,qBAAqB,CAAG,GAAIC,CAAAA,KAAJ,CAAUH,IAAI,CAACI,MAAL,CAAcJ,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAhC,CAA9B,CACA,GAAMC,CAAAA,mBAAmB,CAAG,EAA5B,CAEA,GAAMC,CAAAA,IAAI,CAAG,GAAIH,CAAAA,KAAJ,CAAUH,IAAI,CAACI,MAAL,CAAcJ,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAhC,EAAwCG,IAAxC,CAA6CC,QAA7C,CAAb,CACAF,IAAI,CAACT,qBAAqB,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAT,CAAiBH,SAAS,CAACQ,GAA3B,CAAgCR,SAAS,CAACS,GAA1C,CAAtB,CAAJ,CAA4E,CAA5E,CACA,GAAMC,CAAAA,KAAK,CAAG,GAAIf,CAAAA,YAAJ,EAAd,CACAe,KAAK,CAACC,OAAN,CAAc,CAACX,SAAS,CAACQ,GAAX,CAAgBR,SAAS,CAACS,GAA1B,CAAd,CAA8C,CAA9C,EACA,MAAOC,KAAK,CAACP,MAAb,CAAqB,oBACIO,KAAK,CAACE,OAAN,EADJ,CACbC,GADa,gBACbA,GADa,CACRC,OADQ,gBACRA,OADQ,CAEnB,GAAIC,CAAAA,KAAK,CAAGnB,qBAAqB,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAT,CAAiBU,GAAG,CAAC,CAAD,CAApB,CAAyBA,GAAG,CAAC,CAAD,CAA5B,CAAjC,CACAd,IAAI,CAACc,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,EAAqBG,SAArB,CAAiC,IAAjC,CACA,GAAIjB,IAAI,CAACc,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,EAAqBI,QAAzB,CAAmC,CACjC,MAAO,CAACZ,IAAD,CAAOJ,qBAAP,CAA8BG,mBAA9B,CAAP,CACD,CACD,GAAIC,IAAI,CAACU,KAAD,CAAJ,CAAcD,OAAlB,CAA2B,CACzB,SACD,CAED,GAAII,CAAAA,QAAQ,CAAGrB,qBAAqB,CAACE,IAAD,CAAOc,GAAP,CAAYT,mBAAZ,CAApC,CACA,IAAK,GAAIe,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGD,QAAQ,CAACf,MAA7B,CAAqCgB,CAAC,EAAtC,CAA0C,gCAClBD,QAAQ,CAACC,CAAD,CADU,IACnCC,GADmC,gBAC9BC,QAD8B,gBAExC,GAAIC,CAAAA,EAAE,CAAG1B,qBAAqB,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAT,CAAiBiB,GAAG,CAAC,CAAD,CAApB,CAAyBA,GAAG,CAAC,CAAD,CAA5B,CAA9B,CACA,GAAIrB,IAAI,CAACqB,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,EAAqBJ,SAAzB,CAAoC,CAClC,SACD,CACD,GAAIO,CAAAA,OAAO,CAAGlB,IAAI,CAACU,KAAD,CAAJ,CAAcM,QAA5B,CACA,GAAIE,OAAO,CAAGlB,IAAI,CAACiB,EAAD,CAAlB,CAAwB,CACtBrB,qBAAqB,CAACqB,EAAD,CAArB,CAA4BvB,IAAI,CAACc,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,CAA5B,CACAT,mBAAmB,CAACoB,IAApB,CAAyBzB,IAAI,CAACc,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,CAAzB,EACAR,IAAI,CAACiB,EAAD,CAAJ,CAAWC,OAAX,CACAb,KAAK,CAACC,OAAN,CAAcS,GAAd,CAAmBG,OAAnB,EACD,CACF,CACF,CACD,MAAO,CAAClB,IAAD,CAAOJ,qBAAP,CAA8BG,mBAA9B,CAAP,CACD,CAGD,MAAO,SAASqB,CAAAA,mCAAT,CACL1B,IADK,CAELM,IAFK,CAGLJ,qBAHK,CAILD,SAJK,CAKL0B,OALK,CAML,CACA,GAAMJ,CAAAA,EAAE,CAAG1B,qBAAqB,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAT,CAAiBuB,OAAO,CAAC,CAAD,CAAxB,CAA6BA,OAAO,CAAC,CAAD,CAApC,CAAhC,CACA,GAAIrB,IAAI,CAACiB,EAAD,CAAJ,GAAaf,QAAjB,CAA2B,CACzB,MAAO,EAAP,CACD,CACD,GAAMoB,CAAAA,IAAI,CAAG,EAAb,CACA,IACE,GAAIR,CAAAA,CAAC,CAAGO,OADV,CAEEP,CAAC,EAAI,IAFP,CAGEA,CAAC,CAEGlB,qBAAqB,CAACL,qBAAqB,CAACG,IAAI,CAAC,CAAD,CAAJ,CAAQI,MAAT,CAAiBgB,CAAC,CAACX,GAAnB,CAAwBW,CAAC,CAACV,GAA1B,CAAtB,CAL3B,CAME,CACAkB,IAAI,CAACH,IAAL,CAAUL,CAAV,EACD,CACDQ,IAAI,CAACC,OAAL,GACA,GAAID,IAAI,CAAC,CAAD,CAAJ,GAAY3B,SAAhB,CAA2B,CACzB6B,OAAO,CAACC,GAAR,CAAY,wBAAZ,CAAsCH,IAAI,CAACxB,MAA3C,EACA,MAAOwB,CAAAA,IAAP,CACD,CAHD,IAGO,CACL,MAAO,EAAP,CACD,CACF","sourcesContent":["import { PriortyQueue } from \"./priortyQueue\";\r\nimport {\r\n  gridIndexToArrayIndex,\r\n  neiboursUnvisitedNode,\r\n} from \"./algorithmsHelper\";\r\n\r\n\r\nexport function dijkstra(grid, startNode) {\r\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\r\n  const visitedNodesInOrder = [];\r\n\r\n  const dist = new Array(grid.length * grid[0].length).fill(Infinity);\r\n  dist[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] = 0;\r\n  const queue = new PriortyQueue();\r\n  queue.enqueue([startNode.row, startNode.col], 0);\r\n  while (queue.length) {\r\n    let { val, priorty } = queue.dequeue();\r\n    let index = gridIndexToArrayIndex(grid[0].length, val[0], val[1]);\r\n    grid[val[0]][val[1]].isVisited = true;\r\n    if (grid[val[0]][val[1]].isFinish) {\r\n      return [dist, forPathReconstruction, visitedNodesInOrder];\r\n    }\r\n    if (dist[index] < priorty) {\r\n      continue;\r\n    }\r\n\r\n    let neibours = neiboursUnvisitedNode(grid, val, visitedNodesInOrder);\r\n    for (let i = 0; i < neibours.length; i++) {\r\n      let [idx, currDist] = neibours[i];\r\n      let at = gridIndexToArrayIndex(grid[0].length, idx[0], idx[1]);\r\n      if (grid[idx[0]][idx[1]].isVisited) {\r\n        continue;\r\n      }\r\n      let newDist = dist[index] + currDist;\r\n      if (newDist < dist[at]) {\r\n        forPathReconstruction[at] = grid[val[0]][val[1]];\r\n        visitedNodesInOrder.push(grid[val[0]][val[1]]);\r\n        dist[at] = newDist;\r\n        queue.enqueue(idx, newDist);\r\n      }\r\n    }\r\n  }\r\n  return [dist, forPathReconstruction, visitedNodesInOrder];\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(\r\n  grid,\r\n  dist,\r\n  forPathReconstruction,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const at = gridIndexToArrayIndex(grid[0].length, endNode[0], endNode[1]);\r\n  if (dist[at] === Infinity) {\r\n    return [];\r\n  }\r\n  const path = [];\r\n  for (\r\n    let i = endNode;\r\n    i != null;\r\n    i =\r\n   \r\n        forPathReconstruction[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]\r\n  ) {\r\n    path.push(i);\r\n  }\r\n  path.reverse();\r\n  if (path[0] === startNode) {\r\n    console.log(\"DIjkstra Path Length: \", path.length)\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}