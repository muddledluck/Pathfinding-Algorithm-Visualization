{"ast":null,"code":"import { PriortyQueue } from \"./priortyQueue\";\nimport { gridIndexToArrayIndex, neiboursUnvisitedNode } from \"./algorithmsHelper\";\nexport function dijkstra(grid, startNode) {\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\n  const visitedNodesInOrder = [];\n  const dist = new Array(grid.length * grid[0].length).fill(Infinity);\n  dist[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] = 0;\n  const queue = new PriortyQueue();\n  queue.enqueue([startNode.row, startNode.col], 0);\n\n  while (queue.length) {\n    let {\n      val,\n      priorty\n    } = queue.dequeue();\n    let index = gridIndexToArrayIndex(grid[0].length, val[0], val[1]);\n    grid[val[0]][val[1]].isVisited = true;\n\n    if (grid[val[0]][val[1]].isFinish) {\n      return [dist, forPathReconstruction, visitedNodesInOrder];\n    }\n\n    if (dist[index] < priorty) {\n      continue;\n    }\n\n    let neibours = neiboursUnvisitedNode(grid, val, visitedNodesInOrder);\n\n    for (let i = 0; i < neibours.length; i++) {\n      let [idx, currDist] = neibours[i];\n      let at = gridIndexToArrayIndex(grid[0].length, idx[0], idx[1]);\n\n      if (grid[idx[0]][idx[1]].isVisited) {\n        continue;\n      }\n\n      let newDist = dist[index] + currDist;\n\n      if (newDist < dist[at]) {\n        forPathReconstruction[at] = grid[val[0]][val[1]];\n        visitedNodesInOrder.push(grid[val[0]][val[1]]);\n        dist[at] = newDist;\n        queue.enqueue(idx, newDist);\n      }\n    }\n  }\n\n  return [dist, forPathReconstruction, visitedNodesInOrder];\n}\nexport function getNodesInShortestPathOrderDijkstra(grid, dist, forPathReconstruction, startNode, endNode) {\n  const at = gridIndexToArrayIndex(grid[0].length, endNode[0], endNode[1]);\n\n  if (dist[at] === Infinity) {\n    return [];\n  }\n\n  const path = [];\n\n  for (let i = endNode; i != null; i = forPathReconstruction[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]) {\n    path.push(i);\n  }\n\n  path.reverse();\n\n  if (path[0] === startNode) {\n    return path;\n  } else {\n    return [];\n  }\n}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/Dijkstra.jsx"],"names":["PriortyQueue","gridIndexToArrayIndex","neiboursUnvisitedNode","dijkstra","grid","startNode","forPathReconstruction","Array","length","visitedNodesInOrder","dist","fill","Infinity","row","col","queue","enqueue","val","priorty","dequeue","index","isVisited","isFinish","neibours","i","idx","currDist","at","newDist","push","getNodesInShortestPathOrderDijkstra","endNode","path","reverse"],"mappings":"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","sourcesContent":["import { PriortyQueue } from \"./priortyQueue\";\r\nimport {\r\n  gridIndexToArrayIndex,\r\n  neiboursUnvisitedNode,\r\n} from \"./algorithmsHelper\";\r\n\r\n\r\nexport function dijkstra(grid, startNode) {\r\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\r\n  const visitedNodesInOrder = [];\r\n\r\n  const dist = new Array(grid.length * grid[0].length).fill(Infinity);\r\n  dist[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] = 0;\r\n  const queue = new PriortyQueue();\r\n  queue.enqueue([startNode.row, startNode.col], 0);\r\n  while (queue.length) {\r\n    let { val, priorty } = queue.dequeue();\r\n    let index = gridIndexToArrayIndex(grid[0].length, val[0], val[1]);\r\n    grid[val[0]][val[1]].isVisited = true;\r\n    if (grid[val[0]][val[1]].isFinish) {\r\n      return [dist, forPathReconstruction, visitedNodesInOrder];\r\n    }\r\n    if (dist[index] < priorty) {\r\n      continue;\r\n    }\r\n\r\n    let neibours = neiboursUnvisitedNode(grid, val, visitedNodesInOrder);\r\n    for (let i = 0; i < neibours.length; i++) {\r\n      let [idx, currDist] = neibours[i];\r\n      let at = gridIndexToArrayIndex(grid[0].length, idx[0], idx[1]);\r\n      if (grid[idx[0]][idx[1]].isVisited) {\r\n        continue;\r\n      }\r\n      let newDist = dist[index] + currDist;\r\n      if (newDist < dist[at]) {\r\n        forPathReconstruction[at] = grid[val[0]][val[1]];\r\n        visitedNodesInOrder.push(grid[val[0]][val[1]]);\r\n        dist[at] = newDist;\r\n        queue.enqueue(idx, newDist);\r\n      }\r\n    }\r\n  }\r\n  return [dist, forPathReconstruction, visitedNodesInOrder];\r\n}\r\n\r\n\r\nexport function getNodesInShortestPathOrderDijkstra(\r\n  grid,\r\n  dist,\r\n  forPathReconstruction,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const at = gridIndexToArrayIndex(grid[0].length, endNode[0], endNode[1]);\r\n  if (dist[at] === Infinity) {\r\n    return [];\r\n  }\r\n  const path = [];\r\n  for (\r\n    let i = endNode;\r\n    i != null;\r\n    i =\r\n   \r\n        forPathReconstruction[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]\r\n  ) {\r\n    path.push(i);\r\n  }\r\n  path.reverse();\r\n  if (path[0] === startNode) {\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}