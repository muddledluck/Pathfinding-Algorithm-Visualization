{"ast":null,"code":"var direction_row=[-1,1,0,0];var direction_col=[0,0,1,-1];var row_queue=[],col_queue=[];export function bfs(grid,startNode){var forPathReconstruction=new Array(grid.length*grid[0].length);var visitedNodesInOrder=[];row_queue.push(startNode.row);col_queue.push(startNode.col);startNode.isVisited=true;while(row_queue.length){var at_row=row_queue.shift();var at_col=col_queue.shift();if(grid[at_row][at_col].isFinish){break;}updateUnvisitedNeibours(grid,forPathReconstruction,visitedNodesInOrder,at_row,at_col);}return[visitedNodesInOrder,forPathReconstruction];}function updateUnvisitedNeibours(grid,forPathReconstruction,visitedNodesInOrder,at_row,at_col){for(var i=0;i<4;i++){var neibours_row=at_row+direction_row[i];var neibours_col=at_col+direction_col[i];if(neibours_col<0||neibours_row<0||neibours_row>=grid.length||neibours_col>=grid[0].length){continue;}if(grid[neibours_row][neibours_col].isWall){continue;}if(!grid[neibours_row][neibours_col].isVisited){row_queue.push(neibours_row);col_queue.push(neibours_col);grid[neibours_row][neibours_col].isVisited=true;forPathReconstruction[grid[0].length*neibours_row+neibours_col]=grid[at_row][at_col];// visitedNodesInOrder.push(grid[at_row][at_col]);\n}visitedNodesInOrder.push(grid[at_row][at_col]);}}export function getNodesInShortestPathOrderBFS(grid,forPathReconstruction,startNode,endNode){var path=[];console.log(\"endNode\",endNode);for(var i=endNode;i!=null;i=forPathReconstruction[grid[0].length*i.row+i.col]){path.push(i);}path.reverse();console.log(\"path\",path);if(path[0]===startNode){return path;}else{return[];}}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/BFS.jsx"],"names":["direction_row","direction_col","row_queue","col_queue","bfs","grid","startNode","forPathReconstruction","Array","length","visitedNodesInOrder","push","row","col","isVisited","at_row","shift","at_col","isFinish","updateUnvisitedNeibours","i","neibours_row","neibours_col","isWall","getNodesInShortestPathOrderBFS","endNode","path","console","log","reverse"],"mappings":"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","sourcesContent":["const direction_row = [-1, 1, 0, 0];\r\nconst direction_col = [0, 0, 1, -1];\r\n\r\nconst [row_queue, col_queue] = [[], []];\r\n\r\nexport function bfs(grid, startNode) {\r\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\r\n  const visitedNodesInOrder = [];\r\n  row_queue.push(startNode.row);\r\n  col_queue.push(startNode.col);\r\n  startNode.isVisited = true;\r\n  while (row_queue.length) {\r\n    let at_row = row_queue.shift();\r\n    let at_col = col_queue.shift();\r\n    if (grid[at_row][at_col].isFinish) {\r\n      break;\r\n    }\r\n    updateUnvisitedNeibours(\r\n      grid,\r\n      forPathReconstruction,\r\n      visitedNodesInOrder,\r\n      at_row,\r\n      at_col\r\n    );\r\n\t}\r\n  return [visitedNodesInOrder, forPathReconstruction];\r\n}\r\n\r\nfunction updateUnvisitedNeibours(\r\n  grid,\r\n  forPathReconstruction,\r\n  visitedNodesInOrder,\r\n  at_row,\r\n  at_col\r\n) {\r\n  for (let i = 0; i < 4; i++) {\r\n    let neibours_row = at_row + direction_row[i];\r\n    let neibours_col = at_col + direction_col[i];\r\n    if (\r\n      neibours_col < 0 ||\r\n      neibours_row < 0 ||\r\n      neibours_row >= grid.length ||\r\n      neibours_col >= grid[0].length\r\n    ) {\r\n      continue;\r\n    }\r\n    if (grid[neibours_row][neibours_col].isWall) {\r\n      continue;\r\n    }\r\n    if (!grid[neibours_row][neibours_col].isVisited) {\r\n      row_queue.push(neibours_row);\r\n\t\t\tcol_queue.push(neibours_col);\r\n\t\t\tgrid[neibours_row][neibours_col].isVisited = true;\r\n      forPathReconstruction[grid[0].length * neibours_row + neibours_col] =\r\n        grid[at_row][at_col];\r\n      // visitedNodesInOrder.push(grid[at_row][at_col]);\r\n    }\r\n    visitedNodesInOrder.push(grid[at_row][at_col]);\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(\r\n  grid,\r\n  forPathReconstruction,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const path = [];\r\n\tconsole.log(\"endNode\", endNode)\r\n\tfor (\r\n    let i = endNode;\r\n    i != null;\r\n    i = forPathReconstruction[grid[0].length * i.row + i.col]\r\n\t) {\r\n    path.push(i);\r\n  }\r\n\tpath.reverse();\r\n\tconsole.log(\"path\", path)\r\n  if (path[0] === startNode) {\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}