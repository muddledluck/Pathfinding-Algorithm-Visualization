{"ast":null,"code":"const direction_row = [-1, 1, 0, 0];\nconst direction_col = [0, 0, 1, -1];\nconst [row_queue, col_queue] = [[], []];\nexport function bfs(grid, startNode) {\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\n  const visitedNodesInOrder = [];\n  row_queue.push(startNode.row);\n  col_queue.push(startNode.col);\n  startNode.isVisited = true;\n\n  while (row_queue.length) {\n    let at_row = row_queue.shift();\n    let at_col = col_queue.shift();\n\n    if (grid[at_row][at_col].isFinish) {\n      break;\n    }\n\n    updateUnvisitedNeibours(grid, forPathReconstruction, visitedNodesInOrder, at_row, at_col);\n  }\n\n  return [visitedNodesInOrder, forPathReconstruction];\n}\n\nfunction updateUnvisitedNeibours(grid, forPathReconstruction, visitedNodesInOrder, at_row, at_col) {\n  for (let i = 0; i < 4; i++) {\n    let neibours_row = at_row + direction_row[i];\n    let neibours_col = at_col + direction_col[i];\n\n    if (neibours_col < 0 || neibours_row < 0 || neibours_row >= grid.length || neibours_col >= grid[0].length) {\n      continue;\n    }\n\n    if (grid[neibours_row][neibours_col].isWall) {\n      continue;\n    }\n\n    if (!grid[neibours_row][neibours_col].isVisited) {\n      row_queue.push(neibours_row);\n      col_queue.push(neibours_col);\n      grid[neibours_row][neibours_col].isVisited = true;\n      forPathReconstruction[grid[0].length * neibours_row + neibours_col] = grid[at_row][at_col]; // visitedNodesInOrder.push(grid[at_row][at_col]);\n    }\n\n    visitedNodesInOrder.push(grid[at_row][at_col]);\n  }\n}\n\nexport function getNodesInShortestPathOrderBFS(grid, forPathReconstruction, startNode, endNode) {\n  const path = [];\n  console.log(\"endNode\", endNode);\n\n  for (let i = endNode; i != null; i = forPathReconstruction[grid[0].length * i.row + i.col]) {\n    path.push(i);\n  }\n\n  path.reverse();\n  console.log(\"path\", path);\n\n  if (path[0] === startNode) {\n    console.log(\"DIjkstra Path Length: \");\n    return path;\n  } else {\n    return [];\n  }\n}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/BFS.jsx"],"names":["direction_row","direction_col","row_queue","col_queue","bfs","grid","startNode","forPathReconstruction","Array","length","visitedNodesInOrder","push","row","col","isVisited","at_row","shift","at_col","isFinish","updateUnvisitedNeibours","i","neibours_row","neibours_col","isWall","getNodesInShortestPathOrderBFS","endNode","path","console","log","reverse"],"mappings":"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","sourcesContent":["const direction_row = [-1, 1, 0, 0];\r\nconst direction_col = [0, 0, 1, -1];\r\n\r\nconst [row_queue, col_queue] = [[], []];\r\n\r\nexport function bfs(grid, startNode) {\r\n  const forPathReconstruction = new Array(grid.length * grid[0].length);\r\n  const visitedNodesInOrder = [];\r\n  row_queue.push(startNode.row);\r\n  col_queue.push(startNode.col);\r\n  startNode.isVisited = true;\r\n  while (row_queue.length) {\r\n    let at_row = row_queue.shift();\r\n    let at_col = col_queue.shift();\r\n    if (grid[at_row][at_col].isFinish) {\r\n      break;\r\n    }\r\n    updateUnvisitedNeibours(\r\n      grid,\r\n      forPathReconstruction,\r\n      visitedNodesInOrder,\r\n      at_row,\r\n      at_col\r\n    );\r\n\t}\r\n  return [visitedNodesInOrder, forPathReconstruction];\r\n}\r\n\r\nfunction updateUnvisitedNeibours(\r\n  grid,\r\n  forPathReconstruction,\r\n  visitedNodesInOrder,\r\n  at_row,\r\n  at_col\r\n) {\r\n  for (let i = 0; i < 4; i++) {\r\n    let neibours_row = at_row + direction_row[i];\r\n    let neibours_col = at_col + direction_col[i];\r\n    if (\r\n      neibours_col < 0 ||\r\n      neibours_row < 0 ||\r\n      neibours_row >= grid.length ||\r\n      neibours_col >= grid[0].length\r\n    ) {\r\n      continue;\r\n    }\r\n    if (grid[neibours_row][neibours_col].isWall) {\r\n      continue;\r\n    }\r\n    if (!grid[neibours_row][neibours_col].isVisited) {\r\n      row_queue.push(neibours_row);\r\n\t\t\tcol_queue.push(neibours_col);\r\n\t\t\tgrid[neibours_row][neibours_col].isVisited = true;\r\n      forPathReconstruction[grid[0].length * neibours_row + neibours_col] =\r\n        grid[at_row][at_col];\r\n      // visitedNodesInOrder.push(grid[at_row][at_col]);\r\n    }\r\n    visitedNodesInOrder.push(grid[at_row][at_col]);\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrderBFS(\r\n  grid,\r\n  forPathReconstruction,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const path = [];\r\n\tconsole.log(\"endNode\", endNode)\r\n\tfor (\r\n    let i = endNode;\r\n    i != null;\r\n    i = forPathReconstruction[grid[0].length * i.row + i.col]\r\n\t) {\r\n    path.push(i);\r\n  }\r\n\tpath.reverse();\r\n\tconsole.log(\"path\", path)\r\n  if (path[0] === startNode) {\r\n    console.log(\"DIjkstra Path Length: \",)\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}