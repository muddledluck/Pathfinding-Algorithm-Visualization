{"ast":null,"code":"import _slicedToArray from\"F:\\\\Coding\\\\React\\\\path-finding-visualizer\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";import{PriortyQueue}from\"./priortyQueue\";import{gridIndexToArrayIndex,neiboursUnvisitedNode}from\"./algorithmsHelper\";function heuristic(nodeOne,nodeTwo){var manhattanDistance=Math.abs(nodeOne[0]-nodeTwo[0])+Math.abs(nodeOne[1]-nodeTwo[1]);// let diagonalDistance = Math.max(Math.abs(nodeOne[0] - nodeTwo[0]), Math.abs(nodeOne[1] - nodeTwo[1]))\n// let euclideanDistance = Math.sqrt(Math.pow((nodeOne[0] - nodeTwo[0]), 2) + Math.pow((nodeOne[1] - nodeTwo[1]), 2))\nreturn manhattanDistance;}export function A_Star(grid,startNode,endNode){var TOTAL_NODE=grid.length*grid[0].length;var openSet=new PriortyQueue();// queue\nvar forPathReconstruntion=new Array(TOTAL_NODE);var visitedNodesInOrder=[];var gScore=new Array(TOTAL_NODE).fill(Infinity);gScore[gridIndexToArrayIndex(grid[0].length,startNode.row,startNode.col)]=0;var fScore=new Array(TOTAL_NODE).fill(Infinity);fScore[gridIndexToArrayIndex(grid[0].length,startNode.row,startNode.col)]=gScore[gridIndexToArrayIndex(grid[0].length,startNode.row,startNode.col)]+heuristic([startNode.row,startNode.col],[endNode.row,endNode.col]);openSet.enqueue([startNode.row,startNode.col],fScore[0]);while(openSet.length){var _openSet$dequeue=openSet.dequeue(),val=_openSet$dequeue.val;if(grid[val[0]][val[1]].isVisited){continue;}var current=val;grid[current[0]][current[1]].isVisited=true;if(current[0]===endNode.row&&current[1]===endNode.col){return[forPathReconstruntion,visitedNodesInOrder];}var neibours=neiboursUnvisitedNode(grid,current,visitedNodesInOrder);for(var i=0;i<neibours.length;i++){var _neibours$i=_slicedToArray(neibours[i],2),neb=_neibours$i[0],weight=_neibours$i[1];if(grid[neb[0]][neb[1]].isVisited){continue;}var new_gScore=gScore[gridIndexToArrayIndex(grid[0].length,current[0],current[1])]+weight;if(new_gScore<gScore[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]){// visitedNodesInOrder.push(grid[current[0]][current[1]])\nforPathReconstruntion[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]=grid[current[0]][current[1]];gScore[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]=new_gScore;fScore[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]=gScore[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]+heuristic(neb,[endNode.row,endNode.col]);if(!grid[neb[0]][neb[1]].isVisited){openSet.enqueue(neb,fScore[gridIndexToArrayIndex(grid[0].length,neb[0],neb[1])]);}}}}return[forPathReconstruntion,visitedNodesInOrder];}export function getNodesInShortestPathOrderAStar(grid,forPathReconstruntion,startNode,endNode){var path=[];for(var i=endNode;i!=null;i=forPathReconstruntion[gridIndexToArrayIndex(grid[0].length,i.row,i.col)]){path.push(i);}path.reverse();if(path[0]===startNode){console.log(\"A_Star Path Length: \",path.length);return path;}else{return[];}}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/A_Star.jsx"],"names":["PriortyQueue","gridIndexToArrayIndex","neiboursUnvisitedNode","heuristic","nodeOne","nodeTwo","manhattanDistance","Math","abs","A_Star","grid","startNode","endNode","TOTAL_NODE","length","openSet","forPathReconstruntion","Array","visitedNodesInOrder","gScore","fill","Infinity","row","col","fScore","enqueue","dequeue","val","isVisited","current","neibours","i","neb","weight","new_gScore","getNodesInShortestPathOrderAStar","path","push","reverse","console","log"],"mappings":"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","sourcesContent":["import { PriortyQueue } from \"./priortyQueue\";\r\nimport {\r\n  gridIndexToArrayIndex,\r\n  neiboursUnvisitedNode,\r\n} from \"./algorithmsHelper\";\r\n\r\nfunction heuristic(nodeOne, nodeTwo) {\r\n  let manhattanDistance =\r\n    Math.abs(nodeOne[0] - nodeTwo[0]) + Math.abs(nodeOne[1] - nodeTwo[1]);\r\n  // let diagonalDistance = Math.max(Math.abs(nodeOne[0] - nodeTwo[0]), Math.abs(nodeOne[1] - nodeTwo[1]))\r\n  // let euclideanDistance = Math.sqrt(Math.pow((nodeOne[0] - nodeTwo[0]), 2) + Math.pow((nodeOne[1] - nodeTwo[1]), 2))\r\n  return manhattanDistance;\r\n}\r\n\r\nexport function A_Star(grid, startNode, endNode) {\r\n  const TOTAL_NODE = grid.length * grid[0].length;\r\n\r\n  const openSet = new PriortyQueue(); // queue\r\n  const forPathReconstruntion = new Array(TOTAL_NODE);\r\n  const visitedNodesInOrder = [];\r\n\r\n  const gScore = new Array(TOTAL_NODE).fill(Infinity);\r\n  gScore[\r\n    gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)\r\n  ] = 0;\r\n\r\n  const fScore = new Array(TOTAL_NODE).fill(Infinity);\r\n  fScore[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] =\r\n    gScore[\r\n      gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)\r\n    ] + heuristic([startNode.row, startNode.col], [endNode.row, endNode.col]);\r\n\r\n  openSet.enqueue([startNode.row, startNode.col], fScore[0]);\r\n\r\n  while (openSet.length) {\r\n    const { val } = openSet.dequeue();\r\n    if (grid[val[0]][val[1]].isVisited) {\r\n      continue\r\n    }\r\n    const current = val;\r\n    grid[current[0]][current[1]].isVisited = true;\r\n    \r\n    if (current[0] === endNode.row && current[1] === endNode.col) {\r\n      return [forPathReconstruntion, visitedNodesInOrder];\r\n    }\r\n    const neibours = neiboursUnvisitedNode(grid, current, visitedNodesInOrder);\r\n    for (let i = 0; i < neibours.length; i++) {\r\n      const [neb, weight] = neibours[i];\r\n      if (grid[neb[0]][neb[1]].isVisited) {\r\n        continue;\r\n      }\r\n      const new_gScore =\r\n        gScore[gridIndexToArrayIndex(grid[0].length, current[0], current[1])] +\r\n        weight;\r\n      if (\r\n        new_gScore <\r\n        gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]\r\n      ) {\r\n        // visitedNodesInOrder.push(grid[current[0]][current[1]])\r\n        forPathReconstruntion[\r\n          gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])\r\n        ] = grid[current[0]][current[1]];\r\n        gScore[\r\n          gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])\r\n        ] = new_gScore;\r\n        fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] =\r\n          gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] +\r\n          heuristic(neb, [endNode.row, endNode.col]);\r\n        \r\n        if (!grid[neb[0]][neb[1]].isVisited) {\r\n          openSet.enqueue(\r\n            neb,\r\n            fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]\r\n          );\r\n        }\r\n\r\n      }\r\n    }\r\n  }\r\n  return [forPathReconstruntion, visitedNodesInOrder];\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAStar(\r\n  grid,\r\n  forPathReconstruntion,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const path = [];\r\n  for (\r\n    let i = endNode;\r\n    i != null;\r\n    i =\r\n      forPathReconstruntion[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]\r\n  ) {\r\n    path.push(i);\r\n  }\r\n  path.reverse();\r\n  if (path[0] === startNode) {\r\n    console.log(\"A_Star Path Length: \",path.length)\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}