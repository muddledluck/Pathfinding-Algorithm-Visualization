{"ast":null,"code":"export function gridIndexToArrayIndex(totalCol, currentRow, currentCol) {\n  return totalCol * currentRow + currentCol;\n}\nexport function neiboursUnvisitedNode(grid, val, visitedNodesInOrder) {\n  const direction = [[-1, 0], [0, -1], [1, 0], [0, 1]];\n  const neibours = [];\n\n  for (let i = 0; i < 4; i++) {\n    let at = [val[0] + direction[i][0], val[1] + direction[i][1]];\n    let weight;\n\n    if (at[0] < 0 || at[0] >= grid.length || at[1] >= grid[0].length || at[1] < 0) {\n      continue;\n    } else if (grid[at[0]][at[1]].isWall) {\n      continue;\n    } else if (grid[at[0]][at[1]].isWeighted) {\n      visitedNodesInOrder.push(grid[val[0]][val[1]]);\n      weight = 15;\n    } else {\n      // visitedNodesInOrder.push(grid[val[0]][val[1]]);\n      weight = 1;\n    }\n\n    neibours.push([at, weight]);\n  }\n\n  return neibours;\n}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/algorithmsHelper.jsx"],"names":["gridIndexToArrayIndex","totalCol","currentRow","currentCol","neiboursUnvisitedNode","grid","val","visitedNodesInOrder","direction","neibours","i","at","weight","length","isWall","isWeighted","push"],"mappings":"AAAA,OAAO,SAASA,qBAAT,CAA+BC,QAA/B,EAAyCC,UAAzC,EAAqDC,UAArD,EAAiE;AACpE,SAAOF,QAAQ,GAAGC,UAAX,GAAwBC,UAA/B;AACH;AAED,OAAO,SAASC,qBAAT,CAA+BC,IAA/B,EAAqCC,GAArC,EAA0CC,mBAA1C,EAA+D;AAClE,QAAMC,SAAS,GAAG,CAChB,CAAC,CAAC,CAAF,EAAK,CAAL,CADgB,EAEhB,CAAC,CAAD,EAAI,CAAC,CAAL,CAFgB,EAGhB,CAAC,CAAD,EAAI,CAAJ,CAHgB,EAIhB,CAAC,CAAD,EAAI,CAAJ,CAJgB,CAAlB;AAMA,QAAMC,QAAQ,GAAG,EAAjB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC1B,QAAIC,EAAE,GAAG,CAACL,GAAG,CAAC,CAAD,CAAH,GAASE,SAAS,CAACE,CAAD,CAAT,CAAa,CAAb,CAAV,EAA2BJ,GAAG,CAAC,CAAD,CAAH,GAASE,SAAS,CAACE,CAAD,CAAT,CAAa,CAAb,CAApC,CAAT;AACA,QAAIE,MAAJ;;AAEA,QACED,EAAE,CAAC,CAAD,CAAF,GAAQ,CAAR,IACAA,EAAE,CAAC,CAAD,CAAF,IAASN,IAAI,CAACQ,MADd,IAEAF,EAAE,CAAC,CAAD,CAAF,IAASN,IAAI,CAAC,CAAD,CAAJ,CAAQQ,MAFjB,IAGAF,EAAE,CAAC,CAAD,CAAF,GAAQ,CAJV,EAKE;AACA;AACD,KAPD,MAOO,IAAIN,IAAI,CAACM,EAAE,CAAC,CAAD,CAAH,CAAJ,CAAYA,EAAE,CAAC,CAAD,CAAd,EAAmBG,MAAvB,EAA+B;AACpC;AACD,KAFM,MAEA,IAAIT,IAAI,CAACM,EAAE,CAAC,CAAD,CAAH,CAAJ,CAAYA,EAAE,CAAC,CAAD,CAAd,EAAmBI,UAAvB,EAAmC;AACxCR,MAAAA,mBAAmB,CAACS,IAApB,CAAyBX,IAAI,CAACC,GAAG,CAAC,CAAD,CAAJ,CAAJ,CAAaA,GAAG,CAAC,CAAD,CAAhB,CAAzB;AACEM,MAAAA,MAAM,GAAG,EAAT;AACH,KAHM,MAGA;AACL;AACAA,MAAAA,MAAM,GAAG,CAAT;AACD;;AACDH,IAAAA,QAAQ,CAACO,IAAT,CAAc,CAACL,EAAD,EAAKC,MAAL,CAAd;AACD;;AACD,SAAOH,QAAP;AACD","sourcesContent":["export function gridIndexToArrayIndex(totalCol, currentRow, currentCol) {\r\n    return totalCol * currentRow + currentCol;\r\n}\r\n\r\nexport function neiboursUnvisitedNode(grid, val, visitedNodesInOrder) {\r\n    const direction = [\r\n      [-1, 0],\r\n      [0, -1],\r\n      [1, 0],\r\n      [0, 1],\r\n    ];\r\n    const neibours = [];\r\n    for (let i = 0; i < 4; i++) {\r\n      let at = [val[0] + direction[i][0], val[1] + direction[i][1]];\r\n      let weight;\r\n  \r\n      if (\r\n        at[0] < 0 ||\r\n        at[0] >= grid.length ||\r\n        at[1] >= grid[0].length ||\r\n        at[1] < 0\r\n      ) {\r\n        continue;\r\n      } else if (grid[at[0]][at[1]].isWall) {\r\n        continue;\r\n      } else if (grid[at[0]][at[1]].isWeighted) {\r\n        visitedNodesInOrder.push(grid[val[0]][val[1]]);\r\n          weight = 15;\r\n      } else {\r\n        // visitedNodesInOrder.push(grid[val[0]][val[1]]);\r\n        weight = 1;\r\n      }\r\n      neibours.push([at, weight]);\r\n    }\r\n    return neibours;\r\n  }\r\n\r\n"]},"metadata":{},"sourceType":"module"}