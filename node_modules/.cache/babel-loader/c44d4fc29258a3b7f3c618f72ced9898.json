{"ast":null,"code":"var _jsxFileName = \"F:\\\\Coding\\\\React\\\\path-finding-visualizer\\\\src\\\\components\\\\PathFindingVisualizer\\\\PathFindingVisualizer.jsx\";\nimport React from \"react\";\nimport Node from \"../Node/Node\";\nimport { Navbars, wallOrWeight } from \"../Navbars/Navbars\";\nimport { bfs, getNodesInShortestPathOrderBFS } from \"../../algorithms/BFS\";\nimport { dijkstra, getNodesInShortestPathOrderDijkstra } from \"../../algorithms/Dijkstra\";\nimport { A_Star, getNodesInShortestPathOrderAStar } from \"../../algorithms/A_Star\";\nimport \"./PathFindingVisualizer.css\";\nconst TOTAL_ROW = 26;\nconst TOTAL_COL = 56;\nconst STARTING_ROW = 13;\nconst STARTING_COL = 10;\nconst ENDING_ROW = 13;\nconst ENDING_COL = 45;\n\nconst getInitialGrid = () => {\n  const grid = [];\n\n  for (let row = 0; row < TOTAL_ROW; row++) {\n    const currentRow = [];\n\n    for (let col = 0; col < TOTAL_COL; col++) {\n      currentRow.push(createNode(row, col));\n    }\n\n    grid.push(currentRow);\n  }\n\n  return grid;\n};\n\nconst createNode = (row, col) => {\n  return {\n    row,\n    col,\n    isStart: row === STARTING_ROW && col === STARTING_COL,\n    isFinish: row === ENDING_ROW && col === ENDING_COL,\n    isWeighted: false,\n    isVisited: false,\n    isWall: false,\n    previousNode: null\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    isWall: !node.isWall\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithWeight = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = { ...node,\n    isWeighted: !node.isWeighted\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nclass PathFindingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.resetWeight = () => {\n      const {\n        grid\n      } = this.state;\n\n      for (let row = 0; row < TOTAL_ROW; row++) {\n        for (let col = 0; col < TOTAL_COL; col++) {\n          grid[row][col].isWeighted = false;\n        }\n      }\n\n      let resetWeights = document.querySelector(\".node-weight\");\n\n      if (resetWeights === null) {\n        resetWeights = [];\n      }\n\n      for (let i = 0; i < resetWeights.length; i++) {\n        resetWeights[i].className = \"node\";\n      }\n\n      this.setState({\n        grid\n      });\n    };\n\n    this.resetPath = () => {\n      const {\n        grid\n      } = this.state;\n\n      for (let row = 0; row < TOTAL_ROW; row++) {\n        for (let col = 0; col < TOTAL_COL; col++) {\n          grid[row][col].isVisited = false;\n        }\n      }\n\n      const resetPathAnimation = document.querySelectorAll(\".node-shortest-path\");\n      const resetVisitedAnimation = document.querySelectorAll(\".node-visited\");\n\n      for (let i = 0; i < resetVisitedAnimation.length; i++) {\n        if (resetVisitedAnimation[i].classList[2] === \"node-weight\") {\n          resetVisitedAnimation[i].className = \"node node-weight\";\n        } else {\n          resetVisitedAnimation[i].className = \"node\";\n        }\n      }\n\n      for (let i = 0; i < resetPathAnimation.length; i++) {\n        if (resetPathAnimation[i].classList[2] === \"node-weight\") {\n          resetPathAnimation[i].className = \"node node-weight\";\n        } else {\n          resetPathAnimation[i].className = \"node\";\n        }\n      }\n\n      document.getElementById(`node-${STARTING_ROW}-${STARTING_COL}`).className = \"node node-start\";\n      document.getElementById(`node-${ENDING_ROW}-${ENDING_COL}`).className = \"node node-finish\";\n    };\n\n    this.resetGrid = () => {\n      const grid = getInitialGrid();\n      this.setState({\n        grid\n      });\n      this.resetPath();\n    };\n\n    this.handleMouseDown = (row, col) => {\n      if (wallOrWeight === \"wall\") {\n        if (!this.state.grid[row][col].isFinish) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid,\n            mouseIsPressed: true\n          });\n        }\n      } else if (wallOrWeight === \"weight\") {\n        if (!this.state.grid[row][col].isFinish) {\n          const newGrid = getNewGridWithWeight(this.state.grid, row, col);\n          this.setState({\n            gird: newGrid,\n            mouseIsPressed: true\n          });\n        }\n      }\n    };\n\n    this.handleMouseEnter = (row, col) => {\n      if (wallOrWeight === \"wall\") {\n        if (this.state.mouseIsPressed && !this.state.grid[row][col].isFinish) {\n          const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      } else if (wallOrWeight === \"weight\") {\n        if (this.state.mouseIsPressed && !this.state.grid[row][col].isFinish) {\n          const newGrid = getNewGridWithWeight(this.state.grid, row, col);\n          this.setState({\n            grid: newGrid\n          });\n        }\n      }\n    };\n\n    this.handleMouseUp = () => {\n      this.setState({\n        mouseIsPressed: false\n      });\n    };\n\n    this.visualizeAStar = () => {\n      this.resetPath();\n      let {\n        grid\n      } = this.state;\n      const startNode = grid[STARTING_ROW][STARTING_COL];\n      const endNode = grid[ENDING_ROW][ENDING_COL];\n      const [forPathReconstruction, visitedNodesInOrder] = A_Star(grid, startNode, endNode);\n      const nodesInShortestOrder = getNodesInShortestPathOrderAStar(grid, forPathReconstruction, startNode, endNode);\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\n    };\n\n    this.visualizeDijkstra = () => {\n      this.resetPath();\n      let {\n        grid\n      } = this.state;\n      const startNode = grid[STARTING_ROW][STARTING_COL];\n      const endNode = grid[ENDING_ROW][ENDING_COL];\n      const [dist, forPathReconstruction, visitedNodesInOrder] = dijkstra(grid, startNode); // console.log([dist, forPathReconstruction, visitedNodesInOrder])\n\n      const nodesInShortestOrder = getNodesInShortestPathOrderDijkstra(grid, dist, forPathReconstruction, startNode, endNode);\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\n    };\n\n    this.visualizeBFS = () => {\n      this.resetPath();\n      let {\n        grid\n      } = this.state;\n      const startNode = grid[STARTING_ROW][STARTING_COL];\n      const endNode = grid[ENDING_ROW][ENDING_COL];\n      const [visitedNodesInOrder, forPathReconstruction] = bfs(grid, startNode);\n      const nodesInShortestOrder = getNodesInShortestPathOrderBFS(grid, forPathReconstruction, startNode, endNode);\n      this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\n    };\n\n    this.state = {\n      grid: [],\n      mouseIsPressed: false\n    };\n  }\n\n  componentDidMount() {\n    const grid = getInitialGrid();\n    this.setState({\n      grid\n    });\n  }\n\n  animateShortestPath(nodesInShortestOrder) {\n    for (let i = 0; i < nodesInShortestOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path\";\n\n        if (node.isWeighted) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path node-weight\";\n        }\n\n        if (node.isStart) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path node-start\";\n        } else if (node.isFinish) {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path node-finish\";\n        }\n      }, 50 * i);\n    }\n  }\n\n  animateAlgo(visitedNodesInOrder, nodesInShortestOrder) {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestOrder);\n        }, 5 * i);\n        return;\n      }\n\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        setTimeout(() => {\n          document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited\";\n\n          if (node.isWeighted) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-visited node-weight\";\n          }\n\n          if (node.isStart) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path node-start\";\n          } else if (node.isFinish) {\n            document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-shortest-path node-finish\";\n          }\n        }, 5);\n        document.getElementById(`node-${node.row}-${node.col}`).className = \"node node-at\";\n      }, 5 * i);\n    }\n  }\n\n  render() {\n    const {\n      grid\n    } = this.state;\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 280,\n        columnNumber: 7\n      }\n    }, /*#__PURE__*/React.createElement(Navbars, {\n      visualizeBfs: this.visualizeBFS,\n      visualizeDijkstra: this.visualizeDijkstra,\n      visualizeAStar: this.visualizeAStar,\n      resetGrid: this.resetGrid,\n      resetPath: this.resetPath,\n      resetWeight: this.resetWeight,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 281,\n        columnNumber: 9\n      }\n    }), /*#__PURE__*/React.createElement(\"div\", {\n      className: \"grid\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 290,\n        columnNumber: 9\n      }\n    }, grid.map((row, rowIdx) => {\n      return /*#__PURE__*/React.createElement(\"div\", {\n        key: rowIdx,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 293,\n          columnNumber: 15\n        }\n      }, row.map((node, nodeIdx) => {\n        const {\n          row,\n          col,\n          isStart,\n          isFinish,\n          isWall,\n          isWeighted\n        } = node;\n        return /*#__PURE__*/React.createElement(Node, {\n          key: nodeIdx,\n          col: col,\n          isStart: isStart,\n          isFinish: isFinish,\n          isWall: isWall,\n          isWeighted: isWeighted,\n          onMouseDown: this.handleMouseDown,\n          onMouseEnter: this.handleMouseEnter,\n          onMouseUp: this.handleMouseUp,\n          row: row,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 304,\n            columnNumber: 21\n          }\n        });\n      }));\n    })));\n  }\n\n}\n\nexport default PathFindingVisualizer;","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/components/PathFindingVisualizer/PathFindingVisualizer.jsx"],"names":["React","Node","Navbars","wallOrWeight","bfs","getNodesInShortestPathOrderBFS","dijkstra","getNodesInShortestPathOrderDijkstra","A_Star","getNodesInShortestPathOrderAStar","TOTAL_ROW","TOTAL_COL","STARTING_ROW","STARTING_COL","ENDING_ROW","ENDING_COL","getInitialGrid","grid","row","currentRow","col","push","createNode","isStart","isFinish","isWeighted","isVisited","isWall","previousNode","getNewGridWithWallToggled","newGrid","slice","node","newNode","getNewGridWithWeight","PathFindingVisualizer","Component","constructor","props","resetWeight","state","resetWeights","document","querySelector","i","length","className","setState","resetPath","resetPathAnimation","querySelectorAll","resetVisitedAnimation","classList","getElementById","resetGrid","handleMouseDown","mouseIsPressed","gird","handleMouseEnter","handleMouseUp","visualizeAStar","startNode","endNode","forPathReconstruction","visitedNodesInOrder","nodesInShortestOrder","animateAlgo","visualizeDijkstra","dist","visualizeBFS","componentDidMount","animateShortestPath","setTimeout","render","map","rowIdx","nodeIdx"],"mappings":"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","sourcesContent":["import React from \"react\";\r\nimport Node from \"../Node/Node\";\r\nimport { Navbars, wallOrWeight} from \"../Navbars/Navbars\";\r\nimport { bfs, getNodesInShortestPathOrderBFS } from \"../../algorithms/BFS\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrderDijkstra,\r\n} from \"../../algorithms/Dijkstra\";\r\nimport {\r\n  A_Star,\r\n  getNodesInShortestPathOrderAStar,\r\n} from \"../../algorithms/A_Star\";\r\n\r\nimport \"./PathFindingVisualizer.css\";\r\n\r\nconst TOTAL_ROW = 26;\r\nconst TOTAL_COL = 56;\r\n\r\nconst STARTING_ROW = 13;\r\nconst STARTING_COL = 10;\r\n\r\nconst ENDING_ROW = 13;\r\nconst ENDING_COL = 45;\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < TOTAL_ROW; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < TOTAL_COL; col++) {\r\n      currentRow.push(createNode(row, col));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  \r\n  return grid;\r\n};\r\n\r\nconst createNode = (row, col) => {\r\n  \r\n  return {\r\n    row,\r\n    col,\r\n    isStart: row === STARTING_ROW && col === STARTING_COL,\r\n    isFinish: row === ENDING_ROW && col === ENDING_COL,\r\n    isWeighted: false,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n\r\nconst getNewGridWithWeight = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = { ...node, isWeighted: !node.isWeighted }\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n}\r\n\r\n\r\nclass PathFindingVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n  }\r\n\r\n  resetWeight = () => {\r\n    const { grid } = this.state\r\n    for (let row = 0; row < TOTAL_ROW; row++){\r\n      for (let col = 0; col < TOTAL_COL; col++){\r\n        grid[row][col].isWeighted = false;\r\n      }\r\n    }\r\n    let resetWeights = document.querySelector(\".node-weight\")\r\n    if (resetWeights === null) {\r\n      resetWeights = []\r\n    }\r\n    for (let i = 0; i < resetWeights.length; i++){\r\n      resetWeights[i].className = \"node\";\r\n    }\r\n    this.setState({ grid })\r\n  }\r\n  resetPath = () => {\r\n    const { grid } = this.state;\r\n    for (let row = 0; row < TOTAL_ROW; row++) {\r\n      for (let col = 0; col < TOTAL_COL; col++) {\r\n        grid[row][col].isVisited = false;\r\n      }\r\n    }\r\n    const resetPathAnimation = document.querySelectorAll(\".node-shortest-path\");\r\n    const resetVisitedAnimation = document.querySelectorAll(\".node-visited\");\r\n    for (let i = 0; i < resetVisitedAnimation.length; i++) {\r\n      if (resetVisitedAnimation[i].classList[2] === \"node-weight\") {\r\n        resetVisitedAnimation[i].className = \"node node-weight\";\r\n      } else {\r\n        resetVisitedAnimation[i].className = \"node\";\r\n      }\r\n    }\r\n    for (let i = 0; i < resetPathAnimation.length; i++) {\r\n      if (resetPathAnimation[i].classList[2] === \"node-weight\") {\r\n        resetPathAnimation[i].className = \"node node-weight\";\r\n      } else {\r\n        resetPathAnimation[i].className = \"node\";\r\n      }\r\n    }\r\n\r\n    document.getElementById(`node-${STARTING_ROW}-${STARTING_COL}`).className =\r\n      \"node node-start\";\r\n    document.getElementById(`node-${ENDING_ROW}-${ENDING_COL}`).className =\r\n      \"node node-finish\";\r\n  };\r\n\r\n  resetGrid = () => {\r\n    const grid = getInitialGrid();\r\n    this.setState({ grid });\r\n    this.resetPath();\r\n  };\r\n\r\n  handleMouseDown = (row, col) => {\r\n    if (wallOrWeight === \"wall\") {\r\n      if (!this.state.grid[row][col].isFinish) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid, mouseIsPressed: true });\r\n      }\r\n    } else if (wallOrWeight === \"weight\") {\r\n      if (!this.state.grid[row][col].isFinish) {\r\n        const newGrid = getNewGridWithWeight(this.state.grid, row, col);\r\n        this.setState({ gird: newGrid, mouseIsPressed: true });\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseEnter = (row, col) => {\r\n    if (wallOrWeight === \"wall\") {\r\n      if (this.state.mouseIsPressed && !this.state.grid[row][col].isFinish) {\r\n        const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    } else if (wallOrWeight === \"weight\") {\r\n      if (this.state.mouseIsPressed && !this.state.grid[row][col].isFinish) {\r\n        const newGrid = getNewGridWithWeight(this.state.grid, row, col);\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  };\r\n\r\n  handleMouseUp = () => {\r\n    this.setState({ mouseIsPressed: false });\r\n  };\r\n\r\n  animateShortestPath(nodesInShortestOrder) {\r\n    for (let i = 0; i < nodesInShortestOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-shortest-path\";\r\n        if (node.isWeighted) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path node-weight\";\r\n        }\r\n        if (node.isStart) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path node-start\";\r\n        } else if (node.isFinish) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path node-finish\";\r\n        }\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  animateAlgo(visitedNodesInOrder, nodesInShortestOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestOrder);\r\n        }, 5 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        setTimeout(() => {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n          if (node.isWeighted) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-visited node-weight\";\r\n          }\r\n          if (node.isStart) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-shortest-path node-start\";\r\n          } else if (node.isFinish) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              \"node node-shortest-path node-finish\";\r\n          }\r\n        }, 5);\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-at\";\r\n      }, 5 * i);\r\n    }\r\n  }\r\n\r\n  visualizeAStar = () => {\r\n    this.resetPath();\r\n    let { grid } = this.state;\r\n    const startNode = grid[STARTING_ROW][STARTING_COL];\r\n    const endNode = grid[ENDING_ROW][ENDING_COL];\r\n\r\n    const [forPathReconstruction, visitedNodesInOrder] = A_Star(\r\n      grid,\r\n      startNode,\r\n      endNode\r\n    );\r\n    const nodesInShortestOrder = getNodesInShortestPathOrderAStar(\r\n      grid,\r\n      forPathReconstruction,\r\n      startNode,\r\n      endNode\r\n    );\r\n    this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\r\n  };\r\n  visualizeDijkstra = () => {\r\n    this.resetPath();\r\n    let { grid } = this.state;\r\n    const startNode = grid[STARTING_ROW][STARTING_COL];\r\n    const endNode = grid[ENDING_ROW][ENDING_COL];\r\n    const [dist, forPathReconstruction, visitedNodesInOrder] = dijkstra(\r\n      grid,\r\n      startNode\r\n    );\r\n    // console.log([dist, forPathReconstruction, visitedNodesInOrder])\r\n    const nodesInShortestOrder = getNodesInShortestPathOrderDijkstra(\r\n      grid,\r\n      dist,\r\n      forPathReconstruction,\r\n      startNode,\r\n      endNode\r\n    );\r\n    this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\r\n  };\r\n\r\n  visualizeBFS = () => {\r\n    this.resetPath();\r\n    \r\n    let { grid } = this.state;\r\n    const startNode = grid[STARTING_ROW][STARTING_COL];\r\n    const endNode = grid[ENDING_ROW][ENDING_COL];\r\n    const [visitedNodesInOrder, forPathReconstruction] = bfs(grid, startNode);\r\n    const nodesInShortestOrder = getNodesInShortestPathOrderBFS(\r\n      grid,\r\n      forPathReconstruction,\r\n      startNode,\r\n      endNode\r\n    );\r\n    this.animateAlgo(visitedNodesInOrder, nodesInShortestOrder);\r\n  };\r\n\r\n  render() {\r\n    const { grid } = this.state;\r\n    return (\r\n      <div>\r\n        <Navbars\r\n          visualizeBfs={this.visualizeBFS}\r\n          visualizeDijkstra={this.visualizeDijkstra}\r\n          visualizeAStar={this.visualizeAStar}\r\n          resetGrid={this.resetGrid}\r\n          resetPath={this.resetPath}\r\n          resetWeight={this.resetWeight}\r\n          \r\n        ></Navbars>\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    isWall,\r\n                    isWeighted,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      isWall={isWall}\r\n                      isWeighted={isWeighted}\r\n                      onMouseDown={this.handleMouseDown}\r\n                      onMouseEnter={this.handleMouseEnter}\r\n                      onMouseUp={this.handleMouseUp}\r\n                      row={row}\r\n                    />\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathFindingVisualizer;\r\n"]},"metadata":{},"sourceType":"module"}