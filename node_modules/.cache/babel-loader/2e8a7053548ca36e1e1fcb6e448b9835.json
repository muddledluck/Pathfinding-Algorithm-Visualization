{"ast":null,"code":"import { PriortyQueue } from \"./priortyQueue\";\nimport { gridIndexToArrayIndex, neiboursUnvisitedNode } from \"./algorithmsHelper\";\n\nfunction heuristic(nodeOne, nodeTwo) {\n  let manhattanDistance = Math.abs(nodeOne[0] - nodeTwo[0]) + Math.abs(nodeOne[1] - nodeTwo[1]); // let diagonalDistance = Math.max(Math.abs(nodeOne[0] - nodeTwo[0]), Math.abs(nodeOne[1] - nodeTwo[1]))\n  // let euclideanDistance = Math.sqrt(Math.pow((nodeOne[0] - nodeTwo[0]), 2) + Math.pow((nodeOne[1] - nodeTwo[1]), 2))\n\n  return manhattanDistance;\n}\n\nexport function A_Star(grid, startNode, endNode) {\n  const TOTAL_NODE = grid.length * grid[0].length;\n  const openSet = new PriortyQueue(); // queue\n\n  const forPathReconstruntion = new Array(TOTAL_NODE);\n  const visitedNodesInOrder = [];\n  const gScore = new Array(TOTAL_NODE).fill(Infinity);\n  gScore[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] = 0;\n  const fScore = new Array(TOTAL_NODE).fill(Infinity);\n  fScore[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] = gScore[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] + heuristic([startNode.row, startNode.col], [endNode.row, endNode.col]);\n  openSet.enqueue([startNode.row, startNode.col], fScore[0]);\n\n  while (openSet.length) {\n    const {\n      val\n    } = openSet.dequeue();\n    const current = val;\n    grid[current[0]][current[1]].isVisited = true;\n\n    if (current[0] === endNode.row && current[1] === endNode.col) {\n      return [forPathReconstruntion, visitedNodesInOrder];\n    }\n\n    const neibours = neiboursUnvisitedNode(grid, current, visitedNodesInOrder);\n\n    for (let i = 0; i < neibours.length; i++) {\n      const [neb, weight] = neibours[i];\n\n      if (grid[neb[0]][neb[1]].isVisited) {\n        continue;\n      }\n\n      const new_gScore = gScore[gridIndexToArrayIndex(grid[0].length, current[0], current[1])] + weight;\n\n      if (new_gScore < gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]) {\n        // visitedNodesInOrder.push(grid[current[0]][current[1]])\n        forPathReconstruntion[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] = grid[current[0]][current[1]];\n        gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] = new_gScore;\n        fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] = gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] + heuristic(neb, [endNode.row, endNode.col]);\n\n        if (!grid[neb[0]][neb[1]].isVisited) {\n          openSet.enqueue(neb, fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]);\n        }\n      }\n    }\n  }\n\n  return [forPathReconstruntion, visitedNodesInOrder];\n}\nexport function getNodesInShortestPathOrderAStar(grid, forPathReconstruntion, startNode, endNode) {\n  const path = [];\n\n  for (let i = endNode; i != null; i = forPathReconstruntion[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]) {\n    path.push(i);\n  }\n\n  path.reverse();\n\n  if (path[0] === startNode) {\n    return path;\n  } else {\n    return [];\n  }\n}","map":{"version":3,"sources":["F:/Coding/React/path-finding-visualizer/src/algorithms/A_Star.jsx"],"names":["PriortyQueue","gridIndexToArrayIndex","neiboursUnvisitedNode","heuristic","nodeOne","nodeTwo","manhattanDistance","Math","abs","A_Star","grid","startNode","endNode","TOTAL_NODE","length","openSet","forPathReconstruntion","Array","visitedNodesInOrder","gScore","fill","Infinity","row","col","fScore","enqueue","val","dequeue","current","isVisited","neibours","i","neb","weight","new_gScore","getNodesInShortestPathOrderAStar","path","push","reverse"],"mappings":"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","sourcesContent":["import { PriortyQueue } from \"./priortyQueue\";\r\nimport {\r\n  gridIndexToArrayIndex,\r\n  neiboursUnvisitedNode,\r\n} from \"./algorithmsHelper\";\r\n\r\nfunction heuristic(nodeOne, nodeTwo) {\r\n  let manhattanDistance =\r\n    Math.abs(nodeOne[0] - nodeTwo[0]) + Math.abs(nodeOne[1] - nodeTwo[1]);\r\n  // let diagonalDistance = Math.max(Math.abs(nodeOne[0] - nodeTwo[0]), Math.abs(nodeOne[1] - nodeTwo[1]))\r\n  // let euclideanDistance = Math.sqrt(Math.pow((nodeOne[0] - nodeTwo[0]), 2) + Math.pow((nodeOne[1] - nodeTwo[1]), 2))\r\n  return manhattanDistance;\r\n}\r\n\r\nexport function A_Star(grid, startNode, endNode) {\r\n  const TOTAL_NODE = grid.length * grid[0].length;\r\n\r\n  const openSet = new PriortyQueue(); // queue\r\n  const forPathReconstruntion = new Array(TOTAL_NODE);\r\n  const visitedNodesInOrder = [];\r\n\r\n  const gScore = new Array(TOTAL_NODE).fill(Infinity);\r\n  gScore[\r\n    gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)\r\n  ] = 0;\r\n\r\n  const fScore = new Array(TOTAL_NODE).fill(Infinity);\r\n  fScore[gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)] =\r\n    gScore[\r\n      gridIndexToArrayIndex(grid[0].length, startNode.row, startNode.col)\r\n    ] + heuristic([startNode.row, startNode.col], [endNode.row, endNode.col]);\r\n\r\n  openSet.enqueue([startNode.row, startNode.col], fScore[0]);\r\n\r\n  while (openSet.length) {\r\n    const { val } = openSet.dequeue();\r\n    const current = val;\r\n    grid[current[0]][current[1]].isVisited = true;\r\n    if (current[0] === endNode.row && current[1] === endNode.col) {\r\n      return [forPathReconstruntion, visitedNodesInOrder];\r\n    }\r\n    const neibours = neiboursUnvisitedNode(grid, current, visitedNodesInOrder);\r\n    for (let i = 0; i < neibours.length; i++) {\r\n      const [neb, weight] = neibours[i];\r\n      if (grid[neb[0]][neb[1]].isVisited) {\r\n        continue;\r\n      }\r\n      const new_gScore =\r\n        gScore[gridIndexToArrayIndex(grid[0].length, current[0], current[1])] +\r\n        weight;\r\n      if (\r\n        new_gScore <\r\n        gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]\r\n      ) {\r\n        // visitedNodesInOrder.push(grid[current[0]][current[1]])\r\n        forPathReconstruntion[\r\n          gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])\r\n        ] = grid[current[0]][current[1]];\r\n        gScore[\r\n          gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])\r\n        ] = new_gScore;\r\n        fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] =\r\n          gScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])] +\r\n          heuristic(neb, [endNode.row, endNode.col]);\r\n        \r\n        if (!grid[neb[0]][neb[1]].isVisited) {\r\n          openSet.enqueue(\r\n            neb,\r\n            fScore[gridIndexToArrayIndex(grid[0].length, neb[0], neb[1])]\r\n          );\r\n        }\r\n\r\n      }\r\n    }\r\n  }\r\n  return [forPathReconstruntion, visitedNodesInOrder];\r\n}\r\n\r\nexport function getNodesInShortestPathOrderAStar(\r\n  grid,\r\n  forPathReconstruntion,\r\n  startNode,\r\n  endNode\r\n) {\r\n  const path = [];\r\n  for (\r\n    let i = endNode;\r\n    i != null;\r\n    i =\r\n      forPathReconstruntion[gridIndexToArrayIndex(grid[0].length, i.row, i.col)]\r\n  ) {\r\n    path.push(i);\r\n  }\r\n  path.reverse();\r\n  if (path[0] === startNode) {\r\n    return path;\r\n  } else {\r\n    return [];\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}